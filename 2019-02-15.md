1.求数组中每个数字右边第一个比它大的数
使用栈，每当栈顶元素小于处理元素时，记录该值，循环到栈空；
否则继续入栈，直到数组末尾。

2.5种IO模型
Unix下的5种，前4种属于同步IO，第5种属于异步IO：
* 1.阻塞式IO
> 应用程序阻塞，直到数据拷贝完成
* 2.非阻塞式IO
> 在等待数据时，应用程序轮询，CPU开销大
* 3.IO复用(select、poll)
> select阻塞应用程序，数据准备好后结束阻塞，然后才调用IO操作函数，select可管理多个套接字
* 4.信号驱动式IO
> 在等待数据前建立SIGIO信号处理程序，不阻塞应用程序，数据准备好后收到信号，然后调用IO操作函数
* 5.异步IO
> 整个过程都不阻塞，将任务交给内核处理，当数据拷贝完成后才通知应用程序处理数据

IO请求步骤：
存储介质→内核缓冲区(数据准备好)→用户缓冲区(数据拷贝完成)→应用程序处理数据
![https://www.cnblogs.com/Lynn-Zhang/p/5711849.html](https://images2015.cnblogs.com/blog/932784/201607/932784-20160727160025356-310597704.png)

阻塞与非阻塞：进程线程是否需要进入阻塞状态（等待）
同步与异步：用户进程是否主动读写数据，前4种都需要将数据从内核缓冲区拷贝到用户缓冲区

3.操作系统为什么要分内核态和用户态
* 1.保证内核数据安全，高特权栈内存不被低特权任意修改（避免操作系统崩溃）
* 2.会带来一定的额外开销，切换任务时需要保存用户态的寄存器信息，系统调用需要保存用户态的寄存器信息

4.STL里resize和reserve的区别
* resize操作size，reserve操作capacity
* resize后[]一定合法，reserve只是分配预留空间不小于指定值，下标访问不一定合法
* resize = erase + insert，可大可小

5.lower_bound与upper_bound

